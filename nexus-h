import { ItemView, WorkspaceLeaf, Notice, moment, setIcon } from "obsidian";
import NexusHubPlugin from "./main";
import { ReportGenerator } from "./report-generator";
import { AddTransactionModal, GoalsModal, EmergencyFundModal, AccountDetailModal, ManageCreditCardsModal, EditUserModal, ExtraIncomeModal, CardBillDetailModal, ManageBudgetsModal } from "./modals";
import { formatAsCurrency, calculateCardBill } from "./helpers";
import { eventManager } from './EventManager';
import { Transaction, CreditCard } from "./settings";

export const NEXUS_HUB_VIEW_TYPE = "nexus-hub-view";

export class NexusHubView extends ItemView {
    plugin: NexusHubPlugin;
    // Elementos do dashboard para atualização em tempo real
    private generator: ReportGenerator;
    private receitaValueEl: HTMLElement;
    private despesasValueEl: HTMLElement;
    private welcomeEl: HTMLElement;
    private nexusScoreEl: HTMLElement;
    private saldoValueEl: HTMLElement;
    private projectedBalanceEl: HTMLElement; // New card
    // New header elements
    private baseIncomeEl: HTMLElement;
    private extraIncomeEl: HTMLElement;
    private totalIncomeHeaderEl: HTMLElement;
    private accountViewMode: 'pending' | 'paid' = 'pending';
    private budgetContainer: HTMLElement;
    private currentMonth: moment.Moment = moment();

    constructor(leaf: WorkspaceLeaf, plugin: NexusHubPlugin) {
        super(leaf);
        this.plugin = plugin;
        this.generator = new ReportGenerator(this.plugin.settings);
    }

    getViewType() {
        return NEXUS_HUB_VIEW_TYPE;
    }

    getDisplayText() {
        return "Nexus Hub";
    }

    getIcon() {
        return "piggy-bank";
    }

    async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.containerEl.addClass('nexus-hub-view');
    
        const gridContainer = contentEl.createDiv({ cls: 'nexus-hub-grid-container' });
    
        // --- AREA 1: CABEÇALHO ---
        const headerEl = gridContainer.createDiv({ cls: 'grid-area grid-header' });
        const headerContainer = headerEl.createDiv({ cls: 'header-container' });
        this.welcomeEl = headerContainer.createEl('h1', { text: `Olá, ${this.plugin.settings.userName || 'Usuário'}!` });
        const editBtn = headerContainer.createEl('span', { cls: 'edit-user-btn' });
        setIcon(editBtn, 'pencil');
        editBtn.addEventListener('click', () => {
            new EditUserModal(this.app, this.plugin).open();
        });

        this.nexusScoreEl = headerEl.createDiv({ cls: 'nexus-score', text: `Nexus Score: ${this.plugin.settings.nexusScore}` });

        // --- NEW Income Summary in Header ---
        const incomeSummaryHeader = headerEl.createDiv({ cls: 'income-summary-header' });
        this.baseIncomeEl = incomeSummaryHeader.createEl('span', { text: 'Salário: R$ 0,00' });
        this.extraIncomeEl = incomeSummaryHeader.createEl('span', { text: 'Extras: R$ 0,00' });
        this.totalIncomeHeaderEl = incomeSummaryHeader.createEl('span', { text: 'Total: R$ 0,00' });
    
        // --- AREA 2: RESUMO MENSAL ---
        const summaryEl = gridContainer.createDiv({ cls: 'grid-area grid-summary' });
        summaryEl.createEl('h2', { text: 'Resumo Mensal' });
        const summaryContainer = summaryEl.createDiv({ cls: 'stat-card-container' });
        
        const receitaCard = summaryContainer.createDiv({ cls: 'stat-card', attr: {'id': 'receita-total-card'} });
        this.receitaValueEl = receitaCard.createDiv({ cls: "stat-value", text: "R$ 0,00" });
        receitaCard.createDiv({ cls: "stat-label", text: "Receita Total" });
        
        const despesasCard = summaryContainer.createDiv({ cls: 'stat-card', attr: {'id': 'despesas-pendentes-card'} });
        this.despesasValueEl = despesasCard.createDiv({ cls: "stat-value", text: "R$ 0,00" });
        despesasCard.createDiv({ cls: "stat-label", text: "Despesas Pendentes" });
        
        const paidCard = summaryContainer.createDiv({ cls: 'stat-card', attr: {'id': 'pago-no-mes-card'} });
        this.saldoValueEl = paidCard.createDiv({ cls: "stat-value", text: "R$ 0,00" });
        paidCard.createDiv({ cls: "stat-label", text: "Já Pago no Mês" });
        
        const projectedBalanceCard = summaryContainer.createDiv({ cls: 'stat-card', attr: {'id': 'saldo-projetado-card'} });
        this.projectedBalanceEl = projectedBalanceCard.createDiv({ cls: "stat-value", text: "R$ 0,00" });
        projectedBalanceCard.createDiv({ cls: "stat-label", text: "Saldo Projetado" });
        
        // --- AREA 3: AÇÕES E GERENCIAMENTO ---
        const actionsEl = gridContainer.createDiv({ cls: 'grid-area grid-actions' });
        actionsEl.createEl('h2', { text: 'Gerenciamento' });
        
        // Botões principais de ação
        actionsEl.createEl('button', { text: 'Adicionar Transação', cls: 'nexus-hub-button-primary' })
            .addEventListener('click', () => new AddTransactionModal(this.app, this.plugin, () => this.updateDashboardCalculations()).open());
            
        actionsEl.createEl('hr');
    
        // Botões de navegação para os painéis
        const navContainer = actionsEl.createDiv({ cls: 'nav-container' });
        navContainer.createEl('div', { text: 'Definir Orçamentos' }).addEventListener('click', () => new ManageBudgetsModal(this.app, this.plugin).open());
        navContainer.createEl('div', { text: 'Rendas Extras' }).addEventListener('click', () => new ExtraIncomeModal(this.app, this.plugin, this.currentMonth).open());
        navContainer.createEl('div', { text: 'Painel de Metas' }).addEventListener('click', () => new GoalsModal(this.app, this.plugin, 'All').open());
        navContainer.createEl('div', { text: 'Ver Lançamentos Futuros' }).addEventListener('click', () => this.plugin.activateFutureLedgerView());
        navContainer.createEl('div', { text: 'Gerenciar Cartões' }).addEventListener('click', () => new ManageCreditCardsModal(this.app, this.plugin).open());
        navContainer.createEl('div', { text: 'Reserva de Emergência' }).addEventListener('click', () => new EmergencyFundModal(this.app, this.plugin).open());
        navContainer.createEl('div', { text: 'Relatórios' }).addEventListener('click', () => this.plugin.activateReportView());

        actionsEl.createEl('hr');
        actionsEl.createEl('h2', { text: 'Orçamentos do Mês' });
        this.budgetContainer = actionsEl.createDiv({ cls: 'budgets-container' });
    
    
        // --- AREA 4: CONTEÚDO PRINCIPAL (CONTAS A PAGAR) ---
        const mainEl = gridContainer.createDiv({ cls: 'grid-area grid-main-content' });
        mainEl.createEl('h2', { text: 'Transações do Mês' });

        const monthSelectorContainer = mainEl.createDiv({ cls: 'month-selector-container' });

        const prevMonthBtn = monthSelectorContainer.createEl('button', { text: '‹' });
        const monthInput = monthSelectorContainer.createEl('input', { type: 'month' });
        const nextMonthBtn = monthSelectorContainer.createEl('button', { text: '›' });

        monthInput.addEventListener('change', () => {
            if (monthInput.value) {
                this.currentMonth = moment(monthInput.value, 'YYYY-MM');
                this.updateViewForNewMonth();
            }
        });

        prevMonthBtn.addEventListener('click', () => {
            this.currentMonth.subtract(1, 'month');
            this.updateViewForNewMonth();
        });

        nextMonthBtn.addEventListener('click', () => {
            this.currentMonth.add(1, 'month');
            this.updateViewForNewMonth();
        });

        const viewModeContainer = mainEl.createDiv({ cls: 'view-mode-container' });
        const pendingBtn = viewModeContainer.createEl('button', { text: 'A Pagar', cls: 'view-mode-btn' });
        const paidBtn = viewModeContainer.createEl('button', { text: 'Pagos no Mês', cls: 'view-mode-btn' });

        if (this.accountViewMode === 'pending') pendingBtn.addClass('active'); else paidBtn.addClass('active');

        pendingBtn.addEventListener('click', () => {
            if (this.accountViewMode === 'pending') return;
            this.accountViewMode = 'pending';
            pendingBtn.addClass('active');
            paidBtn.removeClass('active');
            this.renderTransactions();
        });
        
        paidBtn.addEventListener('click', () => {
            if (this.accountViewMode === 'paid') return;
            this.accountViewMode = 'paid';
            paidBtn.addClass('active');
            pendingBtn.removeClass('active');
            this.renderTransactions();
        });
    
    
        // --- Renderização Inicial e Eventos ---
        this.updateHeader();
        this.updateViewForNewMonth(); // Chamada inicial para renderizar dados do mês atual
        this.checkForUpcomingBills(); // Verifica contas a vencer ao abrir
    
        // Registra o evento para atualizações em tempo real sempre que os dados do plugin mudarem
        const onDataChange = () => {
            if (this.contentEl.isShown()) {
                this.updateHeader();
                this.updateDashboardCalculations();
                this.renderTransactions();
            }
        };
        eventManager.on('data-changed', onDataChange);

        const onNavigate = (month: moment.Moment) => {
            this.currentMonth = month;
            this.updateViewForNewMonth();
        };
        eventManager.on('navigate-to-month', onNavigate);

        // Registra a função de "limpeza" que será chamada quando a view for fechada, evitando memory leaks.
        this.register(() => {
            eventManager.off('data-changed', onDataChange);
            eventManager.off('navigate-to-month', onNavigate);
        });
    }

    /**
     * Atualiza a UI para refletir um novo mês selecionado.
     */
    private updateViewForNewMonth() {
        // Garante que o seletor de mês reflita o estado atual
        const monthInput = this.contentEl.querySelector('.month-selector-container input[type="month"]') as HTMLInputElement;
        if (monthInput) {
            monthInput.value = this.currentMonth.format('YYYY-MM');
        }

        // Esta função já recalcula tudo e chama renderTransactions() no final
        this.updateDashboardCalculations();
    }

    /**
     * Verifica transações pendentes próximas do vencimento e exibe uma notificação.
     */
    private async checkForUpcomingBills() {
        // Garante que a propriedade exista nas configurações
        if (!this.plugin.settings.notifiedTransactionIds) {
            this.plugin.settings.notifiedTransactionIds = [];
        }

        const upcomingTransactions = this.plugin.settings.transactions.filter(t => {
            if (t.status !== 'pending') return false;
            // Evita re-notificar
            if (this.plugin.settings.notifiedTransactionIds.includes(t.id)) return false;

            const dueDate = moment(t.date);
            const daysUntilDue = dueDate.diff(moment(), 'days');
            return daysUntilDue >= 0 && daysUntilDue <= 3; // Vencendo hoje ou nos próximos 3 dias
        });

        if (upcomingTransactions.length > 0) {
            const notifiedIds: string[] = [];
            upcomingTransactions.forEach(t => {
                new Notice(`Lembrete: '${t.description}' vence ${moment(t.date).fromNow()}.`, 10000); // Notificação dura 10s
                notifiedIds.push(t.id);
            });
            this.plugin.settings.notifiedTransactionIds.push(...notifiedIds);
            await this.plugin.saveSettings();
        }
    }

    /**
     * Atualiza o cabeçalho com o nome do usuário e o score.
     */
    private updateHeader() {
        const userName = this.plugin.settings.userName;
        this.welcomeEl.setText(userName ? `Olá, ${userName}!` : "Bem-vindo ao Nexus Hub!");
        this.nexusScoreEl.setText(`Nexus Score: ${this.plugin.settings.nexusScore}`);
    }

    /**
     * Busca as contas no array de settings e as renderiza na tela.
     */
    private renderTransactionItem(transaction: Transaction, container: HTMLElement) {
        const itemEl = container.createDiv({ cls: "nexus-hub-account-item" });
        itemEl.toggleClass('is-paid', transaction.status === 'paid');
    
        const leftPanel = itemEl.createDiv({ cls: 'account-left-panel' });
    
        // Checkbox para marcar como pago/pendente
        const checkbox = leftPanel.createEl('input', { type: 'checkbox' });
        checkbox.checked = transaction.status === 'paid';
        checkbox.addEventListener('change', async () => {
            const transactionInSettings = this.plugin.settings.transactions.find(t => t.id === transaction.id);
            if (transactionInSettings) {
                transactionInSettings.status = checkbox.checked ? 'paid' : 'pending';
                await this.plugin.saveSettings();
                if (checkbox.checked) { // Only award points on payment
                    const debtGoals = this.plugin.settings.goals.filter(g => g.goalType === 'Quitar Dívida');
                    const matchingGoal = debtGoals.find(g => transactionInSettings.description.includes(g.name));
                    if (matchingGoal) {
                        await this.plugin.increaseNexusScore(5, `Pagamento para a meta '${matchingGoal.name}'`);
                    } else {
                        await this.plugin.increaseNexusScore(1, `Pagamento de '${transactionInSettings.description}'`);
                    }
                }
                eventManager.emit('data-changed'); // Trigger a full UI refresh
            }
        });
    
        const nameContainer = leftPanel.createDiv({ cls: 'account-name' });
        const descriptionEl = nameContainer.createDiv({ text: transaction.description });
        
        if (transaction.isRecurring || transaction.isInstallment) {
            nameContainer.addClass('is-clickable');
            nameContainer.addEventListener('click', () => {
                const groupKey = transaction.isInstallment ? transaction.installmentOf! : transaction.description;
                new AccountDetailModal(this.app, this.plugin, groupKey, transaction.isInstallment).open();
            });
        }

        const dueDateText = `Vence em ${moment(transaction.date).format('DD/MM/YYYY')}`;
        const dueDateEl = nameContainer.createDiv({ cls: "account-due-date", text: dueDateText });
    
        const dueDate = moment(transaction.date);
        const now = moment();
        const daysUntilDue = dueDate.diff(now, 'days');

        if (transaction.status === 'pending') {
            if (dueDate.isBefore(now, 'day')) {
                dueDateEl.addClass('is-overdue');
            } else if (daysUntilDue <= 3) {
                const dueSoonIndicator = nameContainer.createSpan({ cls: 'due-soon-indicator' });
                setIcon(dueSoonIndicator, 'bell');
                dueSoonIndicator.setAttr('title', `Vence em ${daysUntilDue + 1} dia(s)`);
            }
        }
    
        const rightPanel = itemEl.createDiv({ cls: "account-right-panel" });
        const amountEl = rightPanel.createSpan({ text: formatAsCurrency(transaction.amount) });
        // A cor já é tratada pelo CSS geral para despesas, não precisa de classe extra.
    }

    private renderCardBillItem(card: CreditCard, bill: { total: number, dueDate: moment.Moment, transactions: Transaction[] }, container: HTMLElement) {
        const itemEl = container.createDiv({ cls: "nexus-hub-account-item is-credit-card-invoice" });
    
        const leftPanel = itemEl.createDiv({ cls: 'account-left-panel' }); // Adiciona o checkbox aqui

        // Checkbox para marcar a fatura como paga
        const checkbox = leftPanel.createEl('input', { type: 'checkbox' });
        const isBillFullyPaid = bill.transactions.every(t => t.status === 'paid');
        checkbox.checked = isBillFullyPaid;
        itemEl.toggleClass('is-paid', isBillFullyPaid); // Aplica o estilo de "pago" ao item

        checkbox.addEventListener('change', async () => {
            const newStatus = checkbox.checked ? 'paid' : 'pending';
            let scoreAwarded = 0;

            for (const t of bill.transactions) {
                const transactionInSettings = this.plugin.settings.transactions.find(ts => ts.id === t.id);
                if (transactionInSettings && transactionInSettings.status !== newStatus) { // Evita mudar status se já for o mesmo
                    transactionInSettings.status = newStatus;
                    if (newStatus === 'paid') { // Apenas premia se estiver marcando como pago
                        scoreAwarded += 1; // Premia 1 ponto por transação na fatura
                    }
                }
            }
            if (scoreAwarded > 0) await this.plugin.increaseNexusScore(scoreAwarded, `Pagamento de fatura do cartão ${card.name}`);
            await this.plugin.saveSettings();
            eventManager.emit('data-changed'); // Atualiza a UI
        });
        
        const nameContainer = leftPanel.createDiv({ cls: 'account-name is-clickable' });
        nameContainer.addEventListener('click', () => new CardBillDetailModal(this.app, this.plugin, card.id, this.currentMonth).open());
        nameContainer.createDiv({ text: `Fatura ${card.name}` });
        
        const dueDateText = `Vence em ${bill.dueDate.format('DD/MM/YYYY')}`;
        const dueDateEl = nameContainer.createDiv({ cls: "account-due-date", text: dueDateText });
    
        const isBillFullyPaid = bill.transactions.every(t => t.status === 'paid');
        const now = moment();
        const daysUntilDue = bill.dueDate.diff(now, 'days');

        if (!isBillFullyPaid) { // Só mostra alertas para faturas pendentes
            if (bill.dueDate.isBefore(now, 'day')) {
                dueDateEl.addClass('is-overdue');
            } else if (daysUntilDue <= 3) {
                const dueSoonIndicator = nameContainer.createSpan({ cls: 'due-soon-indicator' });
                setIcon(dueSoonIndicator, 'bell');
                dueSoonIndicator.setAttr('title', `Vence em ${daysUntilDue + 1} dia(s)`);
            }
        }
    
        const rightPanel = itemEl.createDiv({ cls: "account-right-panel" });
        rightPanel.createSpan({ text: formatAsCurrency(bill.total) });
    }

    async renderTransactions() {
        const mainEl = this.contentEl.querySelector('.grid-main-content') as HTMLElement;
        if (!mainEl) return;

        this.contentEl.querySelector('.accounts-list-container')?.remove();
        const container = mainEl.createDiv({ cls: 'accounts-list-container' });
        
        // 1. Renderiza transações normais (que não são de cartão de crédito)
        const transactionsForMonth = this.plugin.settings.transactions.filter(t => 
            moment(t.date).isSame(this.currentMonth, 'month') &&
            !t.cardId // Ignora transações de cartão para não serem listadas individualmente
        );
            
        const transactionsToDisplay = transactionsForMonth.filter(t => 
            t.status === this.accountViewMode && t.type === 'expense'
        );
    
        transactionsToDisplay.sort((a, b) => moment(a.date).diff(moment(b.date)));
    
        for (const transaction of transactionsToDisplay) {
            this.renderTransactionItem(transaction, container);
        }

        // 2. Renderiza as faturas de cartão de crédito, respeitando o filtro da aba (A Pagar / Pagos)
        this.plugin.settings.creditCards.forEach(card => {
            const bill = calculateCardBill(card, this.plugin.settings.transactions, this.currentMonth);
            if (bill.total > 0) {
                const isBillPaid = bill.transactions.every(t => t.status === 'paid');
                const billStatus = isBillPaid ? 'paid' : 'pending';

                // Só renderiza a fatura se o status dela corresponder ao modo de visualização da aba
                if (billStatus === this.accountViewMode) {
                    this.renderCardBillItem(card, bill, container);
                }
            }
        });

        // 3. Exibe mensagem se a lista estiver vazia após todas as renderizações
        if (container.childElementCount === 0) {
            const message = this.accountViewMode === 'pending'
                ? "Nenhuma transação pendente para este mês. Bom trabalho!"
                : "Nenhuma transação foi paga neste mês ainda.";
            container.createEl("p", { text: message, cls: 'empty-list-message' });
        }
    }

    /**
     * O coração do dashboard. Calcula e atualiza os valores dos cards de resumo.
     */
    async updateDashboardCalculations() {
        // 1. CÁLCULO DE RENDA
        // A renda base é a transação recorrente de salário
        const recurringIncomeTransaction = this.plugin.settings.transactions.find(t => t.isRecurring && t.type === 'income');
        const baseIncome = recurringIncomeTransaction ? recurringIncomeTransaction.amount : 0;
        
        // As rendas extras são as não recorrentes DO MÊS ATUAL
        const extraIncome = this.plugin.settings.transactions
            .filter(t => 
                !t.isRecurring &&
                t.type === 'income' &&
                moment(t.date).isSame(this.currentMonth, 'month')
            )
            .reduce((sum, t) => sum + t.amount, 0);
        
        const totalIncome = baseIncome + extraIncome;
        
        // 2. CÁLCULO DE DESPESAS DO MÊS
        // Filtra TODAS as transações de despesa pendentes até o final do mês selecionado
        const allPendingExpenses = this.plugin.settings.transactions
            .filter(t => 
                t.type === 'expense' &&
                t.status === 'pending' &&
                moment(t.date).isSameOrBefore(this.currentMonth, 'month')
            );
            
        // Calcula o total de despesas pendentes APENAS para o mês atual
        const pendingForCurrentMonth = allPendingExpenses
            .filter(t => moment(t.date).isSame(this.currentMonth, 'month'))
            .reduce((sum, t) => sum + t.amount, 0);
    
        // Calcula o total pago APENAS no mês atual
        const paidInCurrentMonth = this.plugin.settings.transactions
            .filter(t => 
                t.type === 'expense' &&
                t.status === 'paid' &&
                moment(t.date).isSame(this.currentMonth, 'month')
            )
            .reduce((sum, t) => sum + t.amount, 0);
        
        // 3. CÁLCULO DO SALDO
        const projectedBalance = totalIncome - (pendingForCurrentMonth + paidInCurrentMonth);
    
        // 4. ATUALIZAÇÃO DA UI
        // Atualiza o cabeçalho
        this.baseIncomeEl.setText(`Salário: ${formatAsCurrency(baseIncome)}`);
        this.extraIncomeEl.setText(`Extras: ${formatAsCurrency(extraIncome)}`);
        this.totalIncomeHeaderEl.setText(`Total: ${formatAsCurrency(totalIncome)}`);
    
        // Atualiza os cards de resumo
        this.receitaValueEl.setText(formatAsCurrency(totalIncome));
        this.despesasValueEl.setText(formatAsCurrency(pendingForCurrentMonth));
        this.saldoValueEl.setText(formatAsCurrency(paidInCurrentMonth));
        this.projectedBalanceEl.setText(formatAsCurrency(projectedBalance));
        
        this.projectedBalanceEl.toggleClass('is-negative', projectedBalance < 0);
    
        // Renderiza a lista de transações (esta função também deve usar o filtro por mês)
        this.renderTransactions();
        this.renderBudgets();
    }

    private renderBudgets() {
        this.budgetContainer.empty();
        const budgets = this.plugin.settings.budgets;
    
        if (budgets.length === 0) {
            this.budgetContainer.createEl('p', { text: 'Nenhum orçamento definido.', cls: 'mod-subtle' });
            return;
        }
    
        const spendingData = this.generator.getCommittedSpendingByCategory(
            this.currentMonth.clone().startOf('month'),
            this.currentMonth.clone().endOf('month')
        );
    
        const spendingMap = new Map<string, number>();
        spendingData.labels.forEach((label, index) => {
            const category = this.plugin.settings.categories.find(c => c.name === label);
            if (category) {
                spendingMap.set(category.id, spendingData.data[index]);
            }
        });
    
        budgets.forEach(budget => {
            const category = this.plugin.settings.categories.find(c => c.id === budget.categoryId);
            if (!category) return;
    
            const spentAmount = spendingMap.get(budget.categoryId) || 0;
            const budgetAmount = budget.amount;
            const percentage = budgetAmount > 0 ? (spentAmount / budgetAmount) * 100 : 0;
    
            const itemEl = this.budgetContainer.createDiv({ cls: 'budget-item' });
            
            const headerEl = itemEl.createDiv({ cls: 'budget-item-header' });
            headerEl.createSpan({ text: category.name, cls: 'budget-category-name' });
            headerEl.createSpan({ text: `${Math.min(percentage, 100).toFixed(0)}%`, cls: 'budget-percentage' });
    
            const progressBarWrapper = itemEl.createDiv({ cls: 'progress-bar-wrapper' });
            const progressBarFill = progressBarWrapper.createDiv({ cls: 'progress-bar-fill' });
            progressBarFill.style.width = `${Math.min(percentage, 100)}%`;
    
            if (percentage > 100) progressBarFill.addClass('is-over-limit');
            else if (percentage > 80) progressBarFill.addClass('is-warning');
    
            const footerEl = itemEl.createDiv({ cls: 'budget-item-footer' });
            footerEl.createSpan({ text: `${formatAsCurrency(spentAmount)} de ${formatAsCurrency(budgetAmount)}` });
        });
    }
}